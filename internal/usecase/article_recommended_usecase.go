package usecase

import (
	"SmartBook/internal/model"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"

	"github.com/google/generative-ai-go/genai"
	"google.golang.org/api/option"
)

// GeminiClient は Gemini AI との通信を担当します
type GeminiClient struct {
	client *genai.Client
	model  *genai.GenerativeModel
}

// NewGeminiClient は新しい GeminiClient インスタンスを作成します
func NewGeminiClient() (*GeminiClient, error) {
	apiKey := os.Getenv("GEMINI_API_KEY")
	ctx := context.Background()
	client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
	if err != nil {
		return nil, fmt.Errorf("failed to create Gemini client: %w", err)
	}

	model := client.GenerativeModel("gemini-pro")
	return &GeminiClient{client: client, model: model}, nil
}

func (u *ArticleUseCase) GetRecommendedArticles(ctx context.Context, user *model.User) ([]model.Article, error) {
	allArticles, err := u.GetAllArticles(ctx)
	if err != nil {
		return nil, err
	}

	// ユーザーの行動履歴を文字列化
	userBehavior := formatUserBehavior(user)

	// Gemini AIを使用して推薦を生成
	recommendations, err := u.getAIRecommendations(ctx, userBehavior, allArticles)
	if err != nil {
		// AIが失敗した場合は従来の方法にフォールバック
		fmt.Println("🟡 AI Recommendaion error:", err)
		return u.fallbackRecommendation(user, allArticles), nil
	}

	return recommendations, nil
}

func (u *ArticleUseCase) getAIRecommendations(ctx context.Context, userBehavior string, articles []model.Article) ([]model.Article, error) {
    prompt := fmt.Sprintf(`Given the following user behavior: %s, And the following list of articles: %s, Recommend the top 30 articles for this user. Return the recommendations as a JSON array of article IDs.
Example output format: ["article_id_1", "article_id_2", "article_id_3", ...]`, userBehavior, formatArticlesForAI(articles))
	fmt.Println(userBehavior)

    response, err := u.geminiClient.model.GenerateContent(ctx, genai.Text(prompt))
    if err != nil {
        return nil, fmt.Errorf("failed to generate AI recommendations: %w", err)
    }

    if len(response.Candidates) == 0 || response.Candidates[0].Content == nil {
        return nil, fmt.Errorf("no content generated by AI")
    }

    // AIの応答全体をログに記録
    // fmt.Printf("AI Response: %+v\n", response.Candidates[0].Content)

    var recommendedIDs []string
    for _, part := range response.Candidates[0].Content.Parts {
        if text, ok := part.(genai.Text); ok {
            // JSON配列としてパースを試みる
            if err := json.Unmarshal([]byte(text), &recommendedIDs); err == nil {
                break
            }
            // JSONパースに失敗した場合、テキストから直接IDを抽出
            ids := extractArticleIDs(string(text))
            if len(ids) > 0 {
                recommendedIDs = ids
                break
            }
        }
    }

    if len(recommendedIDs) == 0 {
        return nil, fmt.Errorf("failed to parse AI recommendations")
    }

    // 推奨されたIDをログに記録
    // fmt.Printf("Recommended IDs: %v\n", recommendedIDs)

    return filterArticlesByIDs(articles, recommendedIDs), nil
}

// 文字列からアーティクルIDを抽出する補助関数
func extractArticleIDs(text string) []string {
    // 簡単な正規表現を使用してIDを抽出
    re := regexp.MustCompile(`\b[a-zA-Z0-9_]+_\d+\b`)
    return re.FindAllString(text, -1)
}

func (u *ArticleUseCase) fallbackRecommendation(user *model.User, articles []model.Article) []model.Article {
	fmt.Println("🟡 AI recommendation failed, falling back to traditional recommendation method")
	// 従来のスコアリング方法を使用
	scoredArticles := make([]struct {
		Article model.Article
		Score   float64
	}, len(articles))

	for i, article := range articles {
		score := float64(article.Score)
		for _, interest := range user.Interests {
			if strings.Contains(strings.ToLower(article.Title), strings.ToLower(interest)) {
				score += 100
			}
			for _, tag := range article.Tags {
				if strings.EqualFold(tag, interest) {
					score += 50
				}
			}
		}
		scoredArticles[i] = struct {
			Article model.Article
			Score   float64
		}{Article: article, Score: score}
	}

	sort.Slice(scoredArticles, func(i, j int) bool {
		return scoredArticles[i].Score > scoredArticles[j].Score
	})

	recommendedArticles := make([]model.Article, 0, 30)
	for i := 0; i < 30 && i < len(scoredArticles); i++ {
		recommendedArticles = append(recommendedArticles, scoredArticles[i].Article)
	}

	return recommendedArticles
}

func formatUserBehavior(user *model.User) string {
	// ユーザーの行動履歴を文字列化するロジックを実装
	// 例: 最近閲覧した記事、いいねした記事、よく読むトピックなど
	return fmt.Sprintf("User interests: %s, Recent views: %s, Likes: %s",
		strings.Join(user.Interests, ", "),
		strings.Join(user.RecentViews, ", "),
		strings.Join(user.Likes, ", "),
	)
}

func formatArticlesForAI(articles []model.Article) string {
	var sb strings.Builder
	for _, article := range articles {
		sb.WriteString(fmt.Sprintf("ID: %s, Title: %s, Tags: %s\n", article.ID, article.Title, strings.Join(article.Tags, ", ")))
	}
	return sb.String()
}

func filterArticlesByIDs(articles []model.Article, ids []string) []model.Article {
	idMap := make(map[string]bool)
	for _, id := range ids {
		idMap[id] = true
	}

	var filtered []model.Article
	for _, article := range articles {
		if idMap[article.ID] {
			filtered = append(filtered, article)
		}
	}
	return filtered
}
