package usecase

import (
	"SmartBook/internal/model"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"

	"github.com/google/generative-ai-go/genai"
	"google.golang.org/api/option"
)

// GeminiClient ã¯ Gemini AI ã¨ã®é€šä¿¡ã‚’æ‹…å½“ã—ã¾ã™
type GeminiClient struct {
	client *genai.Client
	model  *genai.GenerativeModel
}

// NewGeminiClient ã¯æ–°ã—ã„ GeminiClient ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™
func NewGeminiClient() (*GeminiClient, error) {
	apiKey := os.Getenv("GEMINI_API_KEY")
	ctx := context.Background()
	client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
	if err != nil {
		return nil, fmt.Errorf("failed to create Gemini client: %w", err)
	}

	model := client.GenerativeModel("gemini-pro")
	return &GeminiClient{client: client, model: model}, nil
}

func (u *ArticleUseCase) GetRecommendedArticles(ctx context.Context, user *model.User) ([]model.Article, error) {
	allArticles, err := u.GetAllArticles(ctx)
	if err != nil {
		return nil, err
	}

	// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¡Œå‹•å±¥æ­´ã‚’æ–‡å­—åˆ—åŒ–
	userBehavior := formatUserBehavior(user)

	// Gemini AIã‚’ä½¿ç”¨ã—ã¦æŽ¨è–¦ã‚’ç”Ÿæˆ
	recommendations, err := u.getAIRecommendations(ctx, userBehavior, allArticles)
	if err != nil {
		// AIãŒå¤±æ•—ã—ãŸå ´åˆã¯å¾“æ¥ã®æ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
		fmt.Println("ðŸŸ¡ AI Recommendaion error:", err)
		return u.fallbackRecommendation(user, allArticles), nil
	}

	return recommendations, nil
}

func (u *ArticleUseCase) getAIRecommendations(ctx context.Context, userBehavior string, articles []model.Article) ([]model.Article, error) {
    prompt := fmt.Sprintf(`Given the following user behavior: %s, And the following list of articles: %s, Recommend the top 30 articles for this user. Return the recommendations as a JSON array of article IDs.
Example output format: ["article_id_1", "article_id_2", "article_id_3", ...]`, userBehavior, formatArticlesForAI(articles))
	fmt.Println(userBehavior)

    response, err := u.geminiClient.model.GenerateContent(ctx, genai.Text(prompt))
    if err != nil {
        return nil, fmt.Errorf("failed to generate AI recommendations: %w", err)
    }

    if len(response.Candidates) == 0 || response.Candidates[0].Content == nil {
        return nil, fmt.Errorf("no content generated by AI")
    }

    // AIã®å¿œç­”å…¨ä½“ã‚’ãƒ­ã‚°ã«è¨˜éŒ²
    // fmt.Printf("AI Response: %+v\n", response.Candidates[0].Content)

    var recommendedIDs []string
    for _, part := range response.Candidates[0].Content.Parts {
        if text, ok := part.(genai.Text); ok {
            // JSONé…åˆ—ã¨ã—ã¦ãƒ‘ãƒ¼ã‚¹ã‚’è©¦ã¿ã‚‹
            if err := json.Unmarshal([]byte(text), &recommendedIDs); err == nil {
                break
            }
            // JSONãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ãŸå ´åˆã€ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ç›´æŽ¥IDã‚’æŠ½å‡º
            ids := extractArticleIDs(string(text))
            if len(ids) > 0 {
                recommendedIDs = ids
                break
            }
        }
    }

    if len(recommendedIDs) == 0 {
        return nil, fmt.Errorf("failed to parse AI recommendations")
    }

    // æŽ¨å¥¨ã•ã‚ŒãŸIDã‚’ãƒ­ã‚°ã«è¨˜éŒ²
    // fmt.Printf("Recommended IDs: %v\n", recommendedIDs)

    return filterArticlesByIDs(articles, recommendedIDs), nil
}

// æ–‡å­—åˆ—ã‹ã‚‰ã‚¢ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«IDã‚’æŠ½å‡ºã™ã‚‹è£œåŠ©é–¢æ•°
func extractArticleIDs(text string) []string {
    // ç°¡å˜ãªæ­£è¦è¡¨ç¾ã‚’ä½¿ç”¨ã—ã¦IDã‚’æŠ½å‡º
    re := regexp.MustCompile(`\b[a-zA-Z0-9_]+_\d+\b`)
    return re.FindAllString(text, -1)
}

func (u *ArticleUseCase) fallbackRecommendation(user *model.User, articles []model.Article) []model.Article {
	fmt.Println("ðŸŸ¡ AI recommendation failed, falling back to traditional recommendation method")
	// å¾“æ¥ã®ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°æ–¹æ³•ã‚’ä½¿ç”¨
	scoredArticles := make([]struct {
		Article model.Article
		Score   float64
	}, len(articles))

	for i, article := range articles {
		score := float64(article.Score)
		for _, interest := range user.Interests {
			if strings.Contains(strings.ToLower(article.Title), strings.ToLower(interest)) {
				score += 100
			}
			for _, tag := range article.Tags {
				if strings.EqualFold(tag, interest) {
					score += 50
				}
			}
		}
		scoredArticles[i] = struct {
			Article model.Article
			Score   float64
		}{Article: article, Score: score}
	}

	sort.Slice(scoredArticles, func(i, j int) bool {
		return scoredArticles[i].Score > scoredArticles[j].Score
	})

	recommendedArticles := make([]model.Article, 0, 30)
	for i := 0; i < 30 && i < len(scoredArticles); i++ {
		recommendedArticles = append(recommendedArticles, scoredArticles[i].Article)
	}

	return recommendedArticles
}

func formatUserBehavior(user *model.User) string {
	// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¡Œå‹•å±¥æ­´ã‚’æ–‡å­—åˆ—åŒ–ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
	// ä¾‹: æœ€è¿‘é–²è¦§ã—ãŸè¨˜äº‹ã€ã„ã„ã­ã—ãŸè¨˜äº‹ã€ã‚ˆãèª­ã‚€ãƒˆãƒ”ãƒƒã‚¯ãªã©
	return fmt.Sprintf("User interests: %s, Recent views: %s, Likes: %s",
		strings.Join(user.Interests, ", "),
		strings.Join(user.RecentViews, ", "),
		strings.Join(user.Likes, ", "),
	)
}

func formatArticlesForAI(articles []model.Article) string {
	var sb strings.Builder
	for _, article := range articles {
		sb.WriteString(fmt.Sprintf("ID: %s, Title: %s, Tags: %s\n", article.ID, article.Title, strings.Join(article.Tags, ", ")))
	}
	return sb.String()
}

func filterArticlesByIDs(articles []model.Article, ids []string) []model.Article {
	idMap := make(map[string]bool)
	for _, id := range ids {
		idMap[id] = true
	}

	var filtered []model.Article
	for _, article := range articles {
		if idMap[article.ID] {
			filtered = append(filtered, article)
		}
	}
	return filtered
}
